namespace tj010
{
    struct UnitModel
    {
        int NumberofNumerator               /* 分子系数的个数，optional，可为空 */;
        int NumberofDenominator             /* 分母系数的个数，optional，可为空 */;
        double NumeratorCoefficient[~]      /* 分子系数  optional，可为空 */;
        double DenominatorCoefficient[~]    /* 分母系数  optional，可为空 */;
        int UnitStepRespLength              /* 阶跃序列长度 */;
        double UnitStepResponse[~]          /* 阶跃响应序列 */;
        int delay                           /* 纯滞后 */;
        double StableGain                   /* 稳态增益 对于积分环节，为稳态增益斜率 */;
        int IntegralMark                    /* 积分标志1：积分环节；0：非积分环节 */;
    };

    struct InputVariable
    {
        int MVType = 1                  /* default: 1  0: DV; 1: MV */; 
        int Status = 1                  /* default: 1   0：检测出现故障；1：正常 */; 
        int ControlStatus               /* 控制状态 default: 0;  0: OFF；1：ON; 2: FeedForward */; 
        int KeyVariable                 /* 关键变量（没用）     default: 0  0: NO; 1: YES */; 
        double HiLimit = 100.0          /* 上限 */; 
        double LoLimit                  /* 下限 */; 
        double PosSpeedLim = 10.0       /* 2022-01-16新增 MV正速率限制  */; 
        double NegSpeedLim = 10.0       /* 2022-01-16新增 MV负速率限制 */; 
        double _IncrConstraint = 10.0   /* 2022-01-16删除   增量约束(SpeedLimit)  */; 
        double IRVExpect = 0.0          /* IRV期望值    default: 0 */; 
        double LinearWeight = 0.0       /* 线性权重    default: 0 */; 
        double QuadraticWeight = 0.0    /* 二次权重    default: 0 */; 
        double SoftHiLimit = 0.0        /* 缓冲区上间距    default: 0 */; 
        double SoftLoLimit = 0.0        /* 缓冲区下间距    default: 0 */; 
        double PRIWeight = 0.0          /* 优先权重（没用）    default: 0 */; 
        double IncrementWeight = 1.0    /* 增量权重    default: 1 */; 
        double ErrorWeight = 0.0        /* 误差权重    default: 0 */; 
        int IntBlock = 15               /* default: 15 */; 
        double DVPrd[~]                 /* default: [], v0.28.1新增, 未来DV的预测数组(不包含当前值！) */
                                        /* self.DVPrd = [] 表示未来的DV预测使用了默认方式：DVprd = [uk] */;

        /* 以下属性不记入TaiJiMPC4.0的ojp工程文件 */
        /* 即：仅允许用脚本修改，作为临时变量，脚本修改结果不存入.ojp的工程文件。*/
        int SetNm = -1          /* 修改MV的控制时域（非负整数），请慎重！*/
                                /* 默认: -1，表示启动控制器(Start Control)时/模型更换时使用内部默认值。*/
                                /* 注意：若要使用内部默认的控制时域，需要：(1)控制器重启(Stop control -> Start control)  或 在线更换模型, (2)SetNm<0 */; 
    };

    struct OutputVariable
    {
        int Status = 1                  /* 状态  default: 1  0：检测出现故障；1：正常 */;
        int ControlStatus = 0           /* 控制状态 0(default): OFF; 1: ON; 2: PRD only;  */;
        int KeyVariable = 0             /* 关键变量（没用）     default: 0  0: NO; 1: YES */;
        int ControlType = 2             /* 控制类型     1：设定值控制；2：区间控制(StickyRange); 3: 区间控制(FreeRange) */;
        double SetPoint = 0.0           /* 设定值 (FTSPBias is included!) */;
        double HiRange = 100.0          /* 区间上限 */;
        double LoRange = 0.0            /* 区间下限 */;
        double ClsLpRsponseTime = 2.0   /* 闭环响应时间（单位：分钟） */;
        double IRVExpect = 0.0          /* IRV期望值    default: 0 */;
        double LinearWeight = 0.0       /* 线性权重    default: 0 */;
        double QuadraticWeight = 0.0    /* 二次权重    default: 0 */;
        double SoftHiLimit = 0.0        /* 缓冲区上间距default: 0即为优化区域上限间距 */;
        double SoftLoLimit = 0.0        /* 缓冲区下间距default: 0即为优化区域下限间距 */;
        double PRIWeight = 1.0          /* 优先权重  default: 1 */;
        int Priority = 1                /* 优先级 */;
        double ErrorWeight = 1.0        /* 误差权重    default: 1 */;
        double IncrementWeight = 100.0  /* CV 增量权重 2021-09-04新增 */;
        int DistAdaptiveSwt = 0         /* 扰动自适应的开关; 0: OFF, 1: ON. */;
        int DistModelOrder = 0          /* 干扰模型的阶次 */;
        int DistPredHorizon = 6         /* 使用干扰模型进行输出预测的长度 */;
        int DistAdaptiveMode = 2        /* 干扰模型的形式 {0:'', 1:'c0', 2:'c0c1', 3:'c0c1c2'} */;
        int DistAdaptiveDataLen = 3     /* 估计干扰模型的数据长度 */;
        double DistForgettingFactor = 1.0    /* 估计干扰模型的遗忘因子 */;
        double DistFilterCoef = 3.0     /* 合并输出滤波系数 */;
        int FTSPType = 0                /* 0: None, 1:协调控制负荷斜坡, 2:协调控制滑压曲线, 3: 架空稳态层 */;
        double FTSPRate = 0.0           /* Slope Tag in Tai-Ji MPC */;
        double FTSPEnd = 0.0            /* "End SP Tag" (FTSPBias is not included!) or "X Axis End Tag" in Tai-Ji MPC */;
        int FTSPNum = 0                 /* X Axis Cur. Tag in Tai-Ji MPC */;
        astring FTSPXY[~]               /* strFXY in Tai-Ji MPC  */;
        double FTSPTau = 0.0            /* Filter in Tai-Ji MPC */;
        double FTSPBias = 0.0           /* Delta Tag in Tai-Ji MPC */;
        int FTSPHzn = 0                 /* Pred Horizon in Tai-Ji MPC */;

        /* 以下属性不记入TaiJiMPC4.0的ojp工程文件 */
        /* 即：仅允许用脚本修改，作为临时变量，脚本修改结果不存入.ojp的工程文件。 */
        double ErrWtRngFactor = 0.02    /* 2023-03-05 仅在FreeRange条件下起作用。  */
                                        /* 区间内CV误差权重因子(ErrorWeightInRange = ErrWtRngFactor*ErrorWeight)  */;
        double IncWtRngFactor = 0.02    /* 2023-03-05 仅在FreeRange条件下起作用。  */
                                        /* 区间内CV增量权重因子(IncrementWeightInRange = IncWtRngFactor*IncrementWeight) */;
        int IntBlock = 200              /* 修改CV的间隔块数（线性间隔），请慎重！ */;
        int SetNp = -1                  /* 修改CV的预测时域（非负整数），请慎重！ */
                                        /* 默认: -1，表示启动控制器(Start Control)时/模型更换时使用内部默认值。 */
                                        /* 注意：若要使用内部默认的预测时域，需要：(1)控制器重启(Stop control -> Start control) 或 在线更换模型, (2)SetNp<0 */;
    };

    [zpy_ignore]
    struct SetupModelInput
    {
        int InputNum;
        int OutputNum;
        struct UnitModel ControlModel[~];
        struct UnitModel PlantModel[~];
        int ControlModelFlag;
        int PlantModelFlag;
        int ControlInterval;
    };

    [zpy_ignore]
    struct SetupModelOutput
    {
        int iOutput;
        astring szOutput[~];
        float fOutput;
        double dOutput;
        struct UnitModel uModel;
    };

    [function]
    struct SetupModel
    {
        struct SetupModelInput Input;
        struct SetupModelOutput Output;
    };
    
    [function]
    struct NoneArg
    {
    };

    [function]
    struct NoneArgFunctionCall 
    {
    };

    [function]
    struct PureFunctionCall
    {
        string Input[~];
    };

}
